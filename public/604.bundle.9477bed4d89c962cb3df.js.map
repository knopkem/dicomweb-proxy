{"version":3,"file":"604.bundle.9477bed4d89c962cb3df.js","mappings":"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","sources":["webpack:///../../../node_modules/dicomweb-client/src/message.js","webpack:///../../../node_modules/dicomweb-client/src/api.js","webpack:///../../../node_modules/dicomweb-client/src/version.js","webpack:///../../../node_modules/dicomweb-client/src/dicomweb-client.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substr(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength + footerLength;\n\n    return contentArray;\n  });\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Array} The content\n */\nfunction multipartDecode(response) {\n  const message = new Uint8Array(response);\n\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n};\n","import { multipartEncode, multipartDecode } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      console.log(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      console.log(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      console.log(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n  }\n\n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Object} options\n   * @param {Array.<RequestHook>} options.requestHooks - Request hooks.\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, options = {}) {\n    const { errorInterceptor, requestHooks } = this;\n\n    return new Promise((resolve, reject) => {\n      let request = options.request ? options.request : new XMLHttpRequest();\n\n      request.open(method, url, true);\n      if ('responseType' in options) {\n        request.responseType = options.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          request.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        request.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      request.onloadstart = function onloadstart() {\n        // console.log('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      request.onloadend = function onloadend() {\n        // console.log('upload finished')\n      };\n\n      // Handle response message\n      request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n          if (request.status === 200) {\n            resolve(request.response);\n          } else if (request.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', request);\n            }\n            resolve(request.response);\n          } else if (request.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', request);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = request;\n            error.response = request.response;\n            error.status = request.status;\n            if (this.verbose) {\n              console.error('request failed: ', request);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if ('progressCallback' in options) {\n        if (typeof options.progressCallback === 'function') {\n          request.onprogress = options.progressCallback;\n        }\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        request = pipedRequest(request);\n      }\n\n      // Add withCredentials to request if needed\n      if ('withCredentials' in options) {\n        if (options.withCredentials) {\n          request.withCredentials = true;\n        }\n      }\n\n      if ('data' in options) {\n        request.send(options.data);\n      } else {\n        request.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Object} responseType\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, responseType, progressCallback, withCredentials) {\n    return this._httpRequest(url, 'get', headers, {\n      responseType,\n      progressCallback,\n      withCredentials,\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, progressCallback, withCredentials) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n    const responseType = 'json';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Function} progressCallback\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    progressCallback,\n    withCredentials,\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    const responseType = 'arraybuffer';\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      responseType,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(\n      url,\n      headers,\n      'arraybuffer',\n      progressCallback,\n      withCredentials,\n    ).then(multipartDecode);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(\n      url,\n      headers,\n      'arraybuffer',\n      progressCallback,\n      withCredentials,\n    ).then(multipartDecode);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(\n      url,\n      headers,\n      'arraybuffer',\n      progressCallback,\n      withCredentials,\n    ).then(multipartDecode);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    progressCallback,\n    withCredentials,\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    return this._httpGet(\n      url,\n      headers,\n      'arraybuffer',\n      progressCallback,\n      withCredentials,\n    ).then(multipartDecode);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @param {Function} progressCallback\n   * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, progressCallback, withCredentials, request) {\n    return this._httpRequest(url, 'post', headers, {\n      data,\n      progressCallback,\n      withCredentials,\n      request,\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Function} progressCallback\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, progressCallback, withCredentials) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      progressCallback,\n      withCredentials,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n     * Builds an accept header field value for HTTP GET multipart request\n     messages.\n     *\n     * @param {Object[]} mediaTypes - Acceptable media types\n     * @param {Object[]} supportedMediaTypes - Supported media types\n     * @private\n     */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            throw new Error(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    console.log('search for studies');\n    let withCredentials = false;\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    console.log(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {Object} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      console.log(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    console.log(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    let withCredentials = false;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        console.log(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        console.log(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      console.log('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    console.log(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    return this._httpGetApplicationJson(url, {}, false, withCredentials);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    console.log(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(\n        url,\n        headers,\n        'arraybuffer',\n        progressCallback,\n        withCredentials,\n      ).then(multipartDecode);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {String[]} [options.mediaType] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, responseType, false, withCredentials);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      const responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        responseType,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Function} options.progressCallback\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    let withCredentials = false;\n    if ('withCredentials' in options) {\n      if (options.withCredentials) {\n        withCredentials = options.withCredentials;\n      }\n    }\n\n    let progressCallback = false;\n    if ('progressCallback' in options) {\n      progressCallback = options.progressCallback;\n    }\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {String} BulkDataURI - URI for retrieval of bulkdata\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const { withCredentials = false } = options;\n    const { progressCallback = false } = options;\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        byteRange,\n        false,\n        false,\n        withCredentials,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType === MEDIATYPES.OCTET_STREAM) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        byteRange,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        byteRange,\n        false,\n        false,\n        progressCallback,\n        withCredentials,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of bulk data.`,\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };\n    const { withCredentials = false } = options;\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      options.progressCallback,\n      withCredentials,\n      options.request,\n    );\n  }\n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n"],"names":["stringToUint8Array","str","arr","Uint8Array","length","i","j","charCodeAt","containsToken","message","token","offset","index","findToken","maxSearchLength","searchLength","Math","min","multipartEncode","datasets","boundary","s4","floor","random","toString","substring","guid","contentTypeString","header","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","multipartDecode","response","separator","headerIndex","Error","itemLimit","String","fromCharCode","uint8ArrayToString","boundaryString","parts","split","substr","identifyBoundary","boundaryIndex","boundaryLength","components","headerTokenIndex","slice","push","isObject","obj","isEmptyObject","Object","keys","constructor","getFirstResult","result","MEDIATYPES","api","DICOMwebClient","options","this","baseURL","url","console","error","username","password","log","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","requestHooks","headers","errorInterceptor","verbose","method","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","key","setRequestHeader","functions","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","warn","progressCallback","onprogress","isValid","Array","isArray","every","requestHook","areValidRequestHooks","combinedHeaders","assign","metadata","pipedRequest","args","reduce","props","fn","withCredentials","send","_httpRequest","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","mediaTypes","_buildAcceptHeaderFieldValue","byteRange","supportedMediaTypes","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","then","defaultMediaType","acceptableMediaTypes","mediaType","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","contentType","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetImage","_httpGetVideo","_httpGetText","_httpGetApplicationPdf","debug","_httpGetMultipartApplicationDicom","BulkDataURI","queryString","encodeURIComponent","sepIndex","indexOf","mediaTypeType","includes","_assertMediaTypeIsValid","item","fieldValueParts","transferSyntaxUID","fieldValue","values","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","types","Set","type","add","from","sharedMediaTypes"],"sourceRoot":""}