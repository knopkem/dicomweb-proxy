{"version":3,"file":"221.bundle.d903e046b5d45ed1fd7a.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/colorPickerDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/SegmentationToolbox.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getPanelModule.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/hydrationUtils.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/init.ts"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-seg';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import { utils } from '@ohif/core';\r\nimport { metaData, cache, triggerEvent, eventTarget } from '@cornerstonejs/core';\r\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\r\n\r\nlet loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(instances, servicesManager, extensionManager) {\r\n  const instance = instances[0];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'SEG',\r\n    loading: false,\r\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    segments: {},\r\n    sopClassUids,\r\n    instance,\r\n    instances: [instance],\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n  };\r\n\r\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n\r\n  if (!referencedSeriesSequence) {\r\n    console.error('ReferencedSeriesSequence is missing for the SEG');\r\n    return;\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\r\n\r\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n\r\n  displaySet.getReferenceDisplaySet = () => {\r\n    const { displaySetService } = servicesManager.services;\r\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\r\n      displaySet.referencedSeriesInstanceUID\r\n    );\r\n\r\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\r\n      throw new Error('Referenced DisplaySet is missing for the SEG');\r\n    }\r\n\r\n    const referencedDisplaySet = referencedDisplaySets[0];\r\n\r\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\r\n\r\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\r\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\r\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\r\n    displaySet.referencedVolumeId = referencedVolumeId;\r\n\r\n    return referencedDisplaySet;\r\n  };\r\n\r\n  displaySet.load = async ({ headers }) =>\r\n    await _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(segDisplaySet, servicesManager, extensionManager, headers) {\r\n  const { SOPInstanceUID } = segDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  if (\r\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExists(segDisplaySet, segmentationService)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  segDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\r\n      await _loadSegments({\r\n        extensionManager,\r\n        servicesManager,\r\n        segDisplaySet,\r\n        headers,\r\n      });\r\n    }\r\n\r\n    const suppressEvents = true;\r\n    segmentationService\r\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\r\n      .then(() => {\r\n        segDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        segDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nasync function _loadSegments({ extensionManager, servicesManager, segDisplaySet, headers }) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\r\n\r\n  const cachedReferencedVolume = cache.getVolume(segDisplaySet.referencedVolumeId);\r\n\r\n  if (!cachedReferencedVolume) {\r\n    throw new Error(\r\n      'Referenced Volume is missing for the SEG, and stack viewport SEG is not supported yet'\r\n    );\r\n  }\r\n\r\n  const { imageIds } = cachedReferencedVolume;\r\n\r\n  // Todo: what should be defaults here\r\n  const tolerance = 0.001;\r\n  const skipOverlapping = true;\r\n\r\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\r\n    const { percentComplete } = evt.detail;\r\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\r\n      percentComplete,\r\n    });\r\n  });\r\n\r\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.generateToolState(\r\n    imageIds,\r\n    arrayBuffer,\r\n    metaData,\r\n    { skipOverlapping, tolerance, eventTarget, triggerEvent }\r\n  );\r\n\r\n  results.segMetadata.data.forEach((data, i) => {\r\n    if (i > 0) {\r\n      data.rgba = dicomlabToRGB(data.RecommendedDisplayCIELabValue);\r\n    }\r\n  });\r\n\r\n  Object.assign(segDisplaySet, results);\r\n}\r\n\r\nfunction _segmentationExists(segDisplaySet, segmentationService) {\r\n  // This should be abstracted with the CornerstoneCacheService\r\n  return segmentationService.getSegmentation(segDisplaySet.displaySetInstanceUID);\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'dicom-seg',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import dcmjs from 'dcmjs';\r\n\r\n/**\r\n * Converts a CIELAB color to an RGB color using the dcmjs library.\r\n * @param cielab - The CIELAB color to convert.\r\n * @returns The RGB color as an array of three integers between 0 and 255.\r\n */\r\nfunction dicomlabToRGB(cielab: number[]): number[] {\r\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\r\n\r\n  return rgb;\r\n}\r\n\r\nexport { dicomlabToRGB };\r\n","import { Types } from '@ohif/core';\r\n\r\nconst segProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/seg',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  name: 'Segmentations',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'segDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    segDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SEG',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'Segmentations',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: { allowUnmatchedView: true },\r\n          displaySets: [\r\n            {\r\n              id: 'segDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: segProtocol.id,\r\n      protocol: segProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { segProtocol };\r\n","import React from 'react';\r\nimport { Input, Dialog, ButtonEnums } from '@ohif/ui';\r\n\r\nfunction callInputDialog(uiDialogService, label, callback) {\r\n  const dialogId = 'enter-segment-label';\r\n\r\n  const onSubmitHandler = ({ action, value }) => {\r\n    switch (action.id) {\r\n      case 'save':\r\n        callback(value.label, action.id);\r\n        break;\r\n      case 'cancel':\r\n        callback('', action.id);\r\n        break;\r\n    }\r\n    uiDialogService.dismiss({ id: dialogId });\r\n  };\r\n\r\n  if (uiDialogService) {\r\n    uiDialogService.create({\r\n      id: dialogId,\r\n      centralize: true,\r\n      isDraggable: false,\r\n      showOverlay: true,\r\n      content: Dialog,\r\n      contentProps: {\r\n        title: 'Segment',\r\n        value: { label },\r\n        noCloseButton: true,\r\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\r\n        actions: [\r\n          { id: 'cancel', text: 'Cancel', type: ButtonEnums.type.secondary },\r\n          { id: 'save', text: 'Confirm', type: ButtonEnums.type.primary },\r\n        ],\r\n        onSubmit: onSubmitHandler,\r\n        body: ({ value, setValue }) => {\r\n          return (\r\n            <Input\r\n              label=\"Enter the segment label\"\r\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\r\n              autoFocus\r\n              className=\"border-primary-main bg-black\"\r\n              type=\"text\"\r\n              value={value.label}\r\n              onChange={event => {\r\n                event.persist();\r\n                setValue(value => ({ ...value, label: event.target.value }));\r\n              }}\r\n              onKeyPress={event => {\r\n                if (event.key === 'Enter') {\r\n                  onSubmitHandler({ value, action: { id: 'save' } });\r\n                }\r\n              }}\r\n            />\r\n          );\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default callInputDialog;\r\n","import React from 'react';\r\nimport { Dialog } from '@ohif/ui';\r\nimport { ChromePicker } from 'react-color';\r\n\r\nimport './colorPickerDialog.css';\r\n\r\nfunction callColorPickerDialog(uiDialogService, rgbaColor, callback) {\r\n  const dialogId = 'pick-color';\r\n\r\n  const onSubmitHandler = ({ action, value }) => {\r\n    switch (action.id) {\r\n      case 'save':\r\n        callback(value.rgbaColor, action.id);\r\n        break;\r\n      case 'cancel':\r\n        callback('', action.id);\r\n        break;\r\n    }\r\n    uiDialogService.dismiss({ id: dialogId });\r\n  };\r\n\r\n  if (uiDialogService) {\r\n    uiDialogService.create({\r\n      id: dialogId,\r\n      centralize: true,\r\n      isDraggable: false,\r\n      showOverlay: true,\r\n      content: Dialog,\r\n      contentProps: {\r\n        title: 'Segment Color',\r\n        value: { rgbaColor },\r\n        noCloseButton: true,\r\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\r\n        actions: [\r\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\r\n          { id: 'save', text: 'Save', type: 'secondary' },\r\n        ],\r\n        onSubmit: onSubmitHandler,\r\n        body: ({ value, setValue }) => {\r\n          const handleChange = color => {\r\n            setValue({ rgbaColor: color.rgb });\r\n          };\r\n\r\n          return (\r\n            <ChromePicker\r\n              color={value.rgbaColor}\r\n              onChange={handleChange}\r\n              presetColors={[]}\r\n              width={300}\r\n            />\r\n          );\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default callColorPickerDialog;\r\n","import { createReportAsync } from '@ohif/extension-default';\r\nimport React, { useEffect, useState, useCallback } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { SegmentationGroupTable, LegacyButtonGroup, LegacyButton } from '@ohif/ui';\r\n\r\nimport callInputDialog from './callInputDialog';\r\nimport callColorPickerDialog from './colorPickerDialog';\r\nimport { useTranslation } from 'react-i18next';\r\n\r\nexport default function PanelSegmentation({\r\n  servicesManager,\r\n  commandsManager,\r\n  extensionManager,\r\n  configuration,\r\n}) {\r\n  const { segmentationService, viewportGridService, uiDialogService } = servicesManager.services;\r\n\r\n  const { t } = useTranslation('PanelSegmentation');\r\n\r\n  const [selectedSegmentationId, setSelectedSegmentationId] = useState(null);\r\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\r\n    segmentationService.getConfiguration()\r\n  );\r\n\r\n  const [segmentations, setSegmentations] = useState(() => segmentationService.getSegmentations());\r\n\r\n  useEffect(() => {\r\n    // ~~ Subscription\r\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\r\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\r\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\r\n    const subscriptions = [];\r\n\r\n    [added, updated, removed].forEach(evt => {\r\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\r\n        const segmentations = segmentationService.getSegmentations();\r\n        setSegmentations(segmentations);\r\n        setSegmentationConfiguration(segmentationService.getConfiguration());\r\n      });\r\n      subscriptions.push(unsubscribe);\r\n    });\r\n\r\n    return () => {\r\n      subscriptions.forEach(unsub => {\r\n        unsub();\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  const getToolGroupIds = segmentationId => {\r\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n    return toolGroupIds;\r\n  };\r\n\r\n  const onSegmentationAdd = async () => {\r\n    commandsManager.runCommand('createEmptySegmentationForViewport');\r\n  };\r\n\r\n  const onSegmentationClick = (segmentationId: string) => {\r\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\r\n  };\r\n\r\n  const onSegmentationDelete = (segmentationId: string) => {\r\n    segmentationService.remove(segmentationId);\r\n  };\r\n\r\n  const onSegmentAdd = segmentationId => {\r\n    segmentationService.addSegment(segmentationId);\r\n  };\r\n\r\n  const onSegmentClick = (segmentationId, segmentIndex) => {\r\n    segmentationService.setActiveSegment(segmentationId, segmentIndex);\r\n\r\n    const toolGroupIds = getToolGroupIds(segmentationId);\r\n\r\n    toolGroupIds.forEach(toolGroupId => {\r\n      // const toolGroupId =\r\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\r\n      segmentationService.jumpToSegmentCenter(segmentationId, segmentIndex, toolGroupId);\r\n    });\r\n  };\r\n\r\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n    const segment = segmentation.segments[segmentIndex];\r\n    const { label } = segment;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.setSegmentLabel(segmentationId, segmentIndex, label);\r\n    });\r\n  };\r\n\r\n  const onSegmentationEdit = segmentationId => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const { label } = segmentation;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.addOrUpdateSegmentation(\r\n        {\r\n          id: segmentationId,\r\n          label,\r\n        },\r\n        false, // suppress event\r\n        true // notYetUpdatedAtSource\r\n      );\r\n    });\r\n  };\r\n\r\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n    const segment = segmentation.segments[segmentIndex];\r\n    const { color, opacity } = segment;\r\n\r\n    const rgbaColor = {\r\n      r: color[0],\r\n      g: color[1],\r\n      b: color[2],\r\n      a: opacity / 255.0,\r\n    };\r\n\r\n    callColorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\r\n      if (actionId === 'cancel') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.setSegmentRGBAColor(segmentationId, segmentIndex, [\r\n        newRgbaColor.r,\r\n        newRgbaColor.g,\r\n        newRgbaColor.b,\r\n        newRgbaColor.a * 255.0,\r\n      ]);\r\n    });\r\n  };\r\n\r\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\r\n    segmentationService.removeSegment(segmentationId, segmentIndex);\r\n  };\r\n\r\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const segmentInfo = segmentation.segments[segmentIndex];\r\n    const isVisible = !segmentInfo.isVisible;\r\n    const toolGroupIds = getToolGroupIds(segmentationId);\r\n\r\n    // Todo: right now we apply the visibility to all tool groups\r\n    toolGroupIds.forEach(toolGroupId => {\r\n      segmentationService.setSegmentVisibility(\r\n        segmentationId,\r\n        segmentIndex,\r\n        isVisible,\r\n        toolGroupId\r\n      );\r\n    });\r\n  };\r\n\r\n  const onToggleSegmentLock = (segmentationId, segmentIndex) => {\r\n    segmentationService.toggleSegmentLocked(segmentationId, segmentIndex);\r\n  };\r\n\r\n  const onToggleSegmentationVisibility = segmentationId => {\r\n    segmentationService.toggleSegmentationVisibility(segmentationId);\r\n  };\r\n\r\n  const _setSegmentationConfiguration = useCallback(\r\n    (segmentationId, key, value) => {\r\n      segmentationService.setConfiguration({\r\n        segmentationId,\r\n        [key]: value,\r\n      });\r\n    },\r\n    [segmentationService]\r\n  );\r\n\r\n  const onSegmentationDownload = segmentationId => {\r\n    commandsManager.runCommand('downloadSegmentation', {\r\n      segmentationId,\r\n    });\r\n  };\r\n\r\n  const storeSegmentation = async segmentationId => {\r\n    const datasources = extensionManager.getActiveDataSource();\r\n\r\n    const displaySetInstanceUIDs = await createReportAsync({\r\n      servicesManager,\r\n      getReport: () =>\r\n        commandsManager.runCommand('storeSegmentation', {\r\n          segmentationId,\r\n          dataSource: datasources[0],\r\n        }),\r\n      reportType: 'Segmentation',\r\n    });\r\n\r\n    // Show the exported report in the active viewport as read only (similar to SR)\r\n    if (displaySetInstanceUIDs) {\r\n      // clear the segmentation that we exported, similar to the storeMeasurement\r\n      // where we remove the measurements and prompt again the user if they would like\r\n      // to re-read the measurements in a SR read only viewport\r\n      segmentationService.remove(segmentationId);\r\n\r\n      viewportGridService.setDisplaySetsForViewport({\r\n        viewportId: viewportGridService.getActiveViewportId(),\r\n        displaySetInstanceUIDs,\r\n      });\r\n    }\r\n  };\r\n\r\n  const onSegmentationDownloadRTSS = segmentationId => {\r\n    commandsManager.runCommand('downloadRTSS', {\r\n      segmentationId,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className=\"ohif-scrollbar flex min-h-0 flex-auto select-none flex-col justify-between overflow-auto\">\r\n        <SegmentationGroupTable\r\n          title={t('Segmentations')}\r\n          segmentations={segmentations}\r\n          disableEditing={configuration.disableEditing}\r\n          activeSegmentationId={selectedSegmentationId || ''}\r\n          onSegmentationAdd={onSegmentationAdd}\r\n          onSegmentationClick={onSegmentationClick}\r\n          onSegmentationDelete={onSegmentationDelete}\r\n          onSegmentationDownload={onSegmentationDownload}\r\n          onSegmentationDownloadRTSS={onSegmentationDownloadRTSS}\r\n          storeSegmentation={storeSegmentation}\r\n          onSegmentationEdit={onSegmentationEdit}\r\n          onSegmentClick={onSegmentClick}\r\n          onSegmentEdit={onSegmentEdit}\r\n          onSegmentAdd={onSegmentAdd}\r\n          onSegmentColorClick={onSegmentColorClick}\r\n          onSegmentDelete={onSegmentDelete}\r\n          onToggleSegmentVisibility={onToggleSegmentVisibility}\r\n          onToggleSegmentLock={onToggleSegmentLock}\r\n          onToggleSegmentationVisibility={onToggleSegmentationVisibility}\r\n          showDeleteSegment={true}\r\n          segmentationConfig={{ initialConfig: segmentationConfiguration }}\r\n          setRenderOutline={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'renderOutline', value)\r\n          }\r\n          setOutlineOpacityActive={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'outlineOpacity', value)\r\n          }\r\n          setRenderFill={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'renderFill', value)\r\n          }\r\n          setRenderInactiveSegmentations={value =>\r\n            _setSegmentationConfiguration(\r\n              selectedSegmentationId,\r\n              'renderInactiveSegmentations',\r\n              value\r\n            )\r\n          }\r\n          setOutlineWidthActive={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'outlineWidthActive', value)\r\n          }\r\n          setFillAlpha={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'fillAlpha', value)\r\n          }\r\n          setFillAlphaInactive={value =>\r\n            _setSegmentationConfiguration(selectedSegmentationId, 'fillAlphaInactive', value)\r\n          }\r\n        />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nPanelSegmentation.propTypes = {\r\n  commandsManager: PropTypes.shape({\r\n    runCommand: PropTypes.func.isRequired,\r\n  }),\r\n  servicesManager: PropTypes.shape({\r\n    services: PropTypes.shape({\r\n      segmentationService: PropTypes.shape({\r\n        getSegmentation: PropTypes.func.isRequired,\r\n        getSegmentations: PropTypes.func.isRequired,\r\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\r\n        subscribe: PropTypes.func.isRequired,\r\n        EVENTS: PropTypes.object.isRequired,\r\n      }).isRequired,\r\n    }).isRequired,\r\n  }).isRequired,\r\n};\r\n","import React, { useCallback, useEffect, useState, useReducer } from 'react';\r\nimport { AdvancedToolbox, InputDoubleRange, useViewportGrid } from '@ohif/ui';\r\nimport { Types } from '@ohif/extension-cornerstone';\r\nimport { utilities } from '@cornerstonejs/tools';\r\n\r\nconst { segmentation: segmentationUtils } = utilities;\r\n\r\nconst TOOL_TYPES = {\r\n  CIRCULAR_BRUSH: 'CircularBrush',\r\n  SPHERE_BRUSH: 'SphereBrush',\r\n  CIRCULAR_ERASER: 'CircularEraser',\r\n  SPHERE_ERASER: 'SphereEraser',\r\n  CIRCLE_SHAPE: 'CircleScissor',\r\n  RECTANGLE_SHAPE: 'RectangleScissor',\r\n  SPHERE_SHAPE: 'SphereScissor',\r\n  THRESHOLD_CIRCULAR_BRUSH: 'ThresholdCircularBrush',\r\n  THRESHOLD_SPHERE_BRUSH: 'ThresholdSphereBrush',\r\n};\r\n\r\nconst ACTIONS = {\r\n  SET_TOOL_CONFIG: 'SET_TOOL_CONFIG',\r\n  SET_ACTIVE_TOOL: 'SET_ACTIVE_TOOL',\r\n};\r\n\r\nconst initialState = {\r\n  Brush: {\r\n    brushSize: 15,\r\n    mode: 'CircularBrush', // Can be 'CircularBrush' or 'SphereBrush'\r\n  },\r\n  Eraser: {\r\n    brushSize: 15,\r\n    mode: 'CircularEraser', // Can be 'CircularEraser' or 'SphereEraser'\r\n  },\r\n  Shapes: {\r\n    brushSize: 15,\r\n    mode: 'CircleScissor', // E.g., 'CircleScissor', 'RectangleScissor', or 'SphereScissor'\r\n  },\r\n  ThresholdBrush: {\r\n    brushSize: 15,\r\n    thresholdRange: [-500, 500],\r\n  },\r\n  activeTool: null,\r\n};\r\n\r\nfunction toolboxReducer(state, action) {\r\n  switch (action.type) {\r\n    case ACTIONS.SET_TOOL_CONFIG:\r\n      const { tool, config } = action.payload;\r\n      return {\r\n        ...state,\r\n        [tool]: {\r\n          ...state[tool],\r\n          ...config,\r\n        },\r\n      };\r\n    case ACTIONS.SET_ACTIVE_TOOL:\r\n      return { ...state, activeTool: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction SegmentationToolbox({ servicesManager, extensionManager }) {\r\n  const { toolbarService, segmentationService, toolGroupService } =\r\n    servicesManager.services as Types.CornerstoneServices;\r\n\r\n  const [viewportGrid] = useViewportGrid();\r\n  const { viewports, activeViewportId } = viewportGrid;\r\n\r\n  const [toolsEnabled, setToolsEnabled] = useState(false);\r\n  const [state, dispatch] = useReducer(toolboxReducer, initialState);\r\n\r\n  const updateActiveTool = useCallback(() => {\r\n    if (!viewports?.size || activeViewportId === undefined) {\r\n      return;\r\n    }\r\n    const viewport = viewports.get(activeViewportId);\r\n\r\n    if (!viewport) {\r\n      return;\r\n    }\r\n\r\n    dispatch({\r\n      type: ACTIONS.SET_ACTIVE_TOOL,\r\n      payload: toolGroupService.getActiveToolForViewport(viewport.viewportId),\r\n    });\r\n  }, [activeViewportId, viewports, toolGroupService, dispatch]);\r\n\r\n  const setToolActive = useCallback(\r\n    toolName => {\r\n      toolbarService.recordInteraction({\r\n        interactionType: 'tool',\r\n        commands: [\r\n          {\r\n            commandName: 'setToolActive',\r\n            commandOptions: {\r\n              toolName,\r\n            },\r\n          },\r\n        ],\r\n      });\r\n\r\n      dispatch({ type: ACTIONS.SET_ACTIVE_TOOL, payload: toolName });\r\n    },\r\n    [toolbarService, dispatch]\r\n  );\r\n\r\n  /**\r\n   * sets the tools enabled IF there are segmentations\r\n   */\r\n  useEffect(() => {\r\n    const events = [\r\n      segmentationService.EVENTS.SEGMENTATION_ADDED,\r\n      segmentationService.EVENTS.SEGMENTATION_UPDATED,\r\n      segmentationService.EVENTS.SEGMENTATION_REMOVED,\r\n    ];\r\n\r\n    const unsubscriptions = [];\r\n\r\n    events.forEach(event => {\r\n      const { unsubscribe } = segmentationService.subscribe(event, () => {\r\n        const segmentations = segmentationService.getSegmentations();\r\n\r\n        const activeSegmentation = segmentations?.find(seg => seg.isActive);\r\n\r\n        setToolsEnabled(activeSegmentation?.segmentCount > 0);\r\n      });\r\n\r\n      unsubscriptions.push(unsubscribe);\r\n    });\r\n\r\n    updateActiveTool();\r\n\r\n    return () => {\r\n      unsubscriptions.forEach(unsubscribe => unsubscribe());\r\n    };\r\n  }, [activeViewportId, viewports, segmentationService, updateActiveTool]);\r\n\r\n  /**\r\n   * Update the active tool when the toolbar state changes\r\n   */\r\n  useEffect(() => {\r\n    const { unsubscribe } = toolbarService.subscribe(\r\n      toolbarService.EVENTS.TOOL_BAR_STATE_MODIFIED,\r\n      () => {\r\n        updateActiveTool();\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [toolbarService, updateActiveTool]);\r\n\r\n  useEffect(() => {\r\n    // if the active tool is not a brush tool then do nothing\r\n    if (!Object.values(TOOL_TYPES).includes(state.activeTool)) {\r\n      return;\r\n    }\r\n\r\n    // if the tool is Segmentation and it is enabled then do nothing\r\n    if (toolsEnabled) {\r\n      return;\r\n    }\r\n\r\n    // if the tool is Segmentation and it is disabled, then switch\r\n    // back to the window level tool to not confuse the user when no\r\n    // segmentation is active or when there is no segment in the segmentation\r\n    setToolActive('WindowLevel');\r\n  }, [toolsEnabled, state.activeTool, setToolActive]);\r\n\r\n  const updateBrushSize = useCallback(\r\n    (toolName, brushSize) => {\r\n      toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\r\n        segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize, toolName);\r\n      });\r\n    },\r\n    [toolGroupService]\r\n  );\r\n\r\n  const onBrushSizeChange = useCallback(\r\n    (valueAsStringOrNumber, toolCategory) => {\r\n      const value = Number(valueAsStringOrNumber);\r\n\r\n      _getToolNamesFromCategory(toolCategory).forEach(toolName => {\r\n        updateBrushSize(toolName, value);\r\n      });\r\n\r\n      dispatch({\r\n        type: ACTIONS.SET_TOOL_CONFIG,\r\n        payload: {\r\n          tool: toolCategory,\r\n          config: { brushSize: value },\r\n        },\r\n      });\r\n    },\r\n    [toolGroupService, dispatch]\r\n  );\r\n\r\n  const handleRangeChange = useCallback(\r\n    newRange => {\r\n      if (\r\n        newRange[0] === state.ThresholdBrush.thresholdRange[0] &&\r\n        newRange[1] === state.ThresholdBrush.thresholdRange[1]\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const toolNames = _getToolNamesFromCategory('ThresholdBrush');\r\n\r\n      toolNames.forEach(toolName => {\r\n        toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\r\n          const toolGroup = toolGroupService.getToolGroup(toolGroupId);\r\n          toolGroup.setToolConfiguration(toolName, {\r\n            strategySpecificConfiguration: {\r\n              THRESHOLD_INSIDE_CIRCLE: {\r\n                threshold: newRange,\r\n              },\r\n            },\r\n          });\r\n        });\r\n      });\r\n\r\n      dispatch({\r\n        type: ACTIONS.SET_TOOL_CONFIG,\r\n        payload: {\r\n          tool: 'ThresholdBrush',\r\n          config: { thresholdRange: newRange },\r\n        },\r\n      });\r\n    },\r\n    [toolGroupService, dispatch, state.ThresholdBrush.thresholdRange]\r\n  );\r\n\r\n  return (\r\n    <AdvancedToolbox\r\n      title=\"Segmentation Tools\"\r\n      items={[\r\n        {\r\n          name: 'Brush',\r\n          icon: 'icon-tool-brush',\r\n          disabled: !toolsEnabled,\r\n          active:\r\n            state.activeTool === TOOL_TYPES.CIRCULAR_BRUSH ||\r\n            state.activeTool === TOOL_TYPES.SPHERE_BRUSH,\r\n          onClick: () => setToolActive(TOOL_TYPES.CIRCULAR_BRUSH),\r\n          options: [\r\n            {\r\n              name: 'Radius (mm)',\r\n              id: 'brush-radius',\r\n              type: 'range',\r\n              min: 0.5,\r\n              max: 99.5,\r\n              value: state.Brush.brushSize,\r\n              step: 0.5,\r\n              onChange: value => onBrushSizeChange(value, 'Brush'),\r\n            },\r\n            {\r\n              name: 'Mode',\r\n              type: 'radio',\r\n              id: 'brush-mode',\r\n              value: state.Brush.mode,\r\n              values: [\r\n                { value: TOOL_TYPES.CIRCULAR_BRUSH, label: 'Circle' },\r\n                { value: TOOL_TYPES.SPHERE_BRUSH, label: 'Sphere' },\r\n              ],\r\n              onChange: value => setToolActive(value),\r\n            },\r\n          ],\r\n        },\r\n        {\r\n          name: 'Eraser',\r\n          icon: 'icon-tool-eraser',\r\n          disabled: !toolsEnabled,\r\n          active:\r\n            state.activeTool === TOOL_TYPES.CIRCULAR_ERASER ||\r\n            state.activeTool === TOOL_TYPES.SPHERE_ERASER,\r\n          onClick: () => setToolActive(TOOL_TYPES.CIRCULAR_ERASER),\r\n          options: [\r\n            {\r\n              name: 'Radius (mm)',\r\n              type: 'range',\r\n              id: 'eraser-radius',\r\n              min: 0.5,\r\n              max: 99.5,\r\n              value: state.Eraser.brushSize,\r\n              step: 0.5,\r\n              onChange: value => onBrushSizeChange(value, 'Eraser'),\r\n            },\r\n            {\r\n              name: 'Mode',\r\n              type: 'radio',\r\n              id: 'eraser-mode',\r\n              value: state.Eraser.mode,\r\n              values: [\r\n                { value: TOOL_TYPES.CIRCULAR_ERASER, label: 'Circle' },\r\n                { value: TOOL_TYPES.SPHERE_ERASER, label: 'Sphere' },\r\n              ],\r\n              onChange: value => setToolActive(value),\r\n            },\r\n          ],\r\n        },\r\n        {\r\n          name: 'Shapes',\r\n          icon: 'icon-tool-shape',\r\n          disabled: !toolsEnabled,\r\n          active:\r\n            state.activeTool === TOOL_TYPES.CIRCLE_SHAPE ||\r\n            state.activeTool === TOOL_TYPES.RECTANGLE_SHAPE ||\r\n            state.activeTool === TOOL_TYPES.SPHERE_SHAPE,\r\n          onClick: () => setToolActive(TOOL_TYPES.CIRCLE_SHAPE),\r\n          options: [\r\n            {\r\n              name: 'Mode',\r\n              type: 'radio',\r\n              value: state.Shapes.mode,\r\n              id: 'shape-mode',\r\n              values: [\r\n                { value: TOOL_TYPES.CIRCLE_SHAPE, label: 'Circle' },\r\n                { value: TOOL_TYPES.RECTANGLE_SHAPE, label: 'Rectangle' },\r\n                { value: TOOL_TYPES.SPHERE_SHAPE, label: 'Sphere' },\r\n              ],\r\n              onChange: value => setToolActive(value),\r\n            },\r\n          ],\r\n        },\r\n        {\r\n          name: 'Threshold Tool',\r\n          icon: 'icon-tool-threshold',\r\n          disabled: !toolsEnabled,\r\n          active:\r\n            state.activeTool === TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH ||\r\n            state.activeTool === TOOL_TYPES.THRESHOLD_SPHERE_BRUSH,\r\n          onClick: () => setToolActive(TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH),\r\n          options: [\r\n            {\r\n              name: 'Radius (mm)',\r\n              id: 'threshold-radius',\r\n              type: 'range',\r\n              min: 0.5,\r\n              max: 99.5,\r\n              value: state.ThresholdBrush.brushSize,\r\n              step: 0.5,\r\n              onChange: value => onBrushSizeChange(value, 'ThresholdBrush'),\r\n            },\r\n            {\r\n              name: 'Mode',\r\n              type: 'radio',\r\n              id: 'threshold-mode',\r\n              value: state.activeTool,\r\n              values: [\r\n                { value: TOOL_TYPES.THRESHOLD_CIRCULAR_BRUSH, label: 'Circle' },\r\n                { value: TOOL_TYPES.THRESHOLD_SPHERE_BRUSH, label: 'Sphere' },\r\n              ],\r\n              onChange: value => setToolActive(value),\r\n            },\r\n            {\r\n              type: 'custom',\r\n              id: 'segmentation-threshold-range',\r\n              children: () => {\r\n                return (\r\n                  <div>\r\n                    <div className=\"bg-secondary-light h-[1px]\"></div>\r\n                    <div className=\"mt-1 text-[13px] text-white\">Threshold</div>\r\n                    <InputDoubleRange\r\n                      values={state.ThresholdBrush.thresholdRange}\r\n                      onChange={handleRangeChange}\r\n                      minValue={-1000}\r\n                      maxValue={1000}\r\n                      step={1}\r\n                      showLabel={true}\r\n                      allowNumberEdit={true}\r\n                      showAdjustmentArrows={false}\r\n                    />\r\n                  </div>\r\n                );\r\n              },\r\n            },\r\n          ],\r\n        },\r\n      ]}\r\n    />\r\n  );\r\n}\r\n\r\nfunction _getToolNamesFromCategory(category) {\r\n  let toolNames = [];\r\n  switch (category) {\r\n    case 'Brush':\r\n      toolNames = ['CircularBrush', 'SphereBrush'];\r\n      break;\r\n    case 'Eraser':\r\n      toolNames = ['CircularEraser', 'SphereEraser'];\r\n      break;\r\n    case 'ThresholdBrush':\r\n      toolNames = ['ThresholdCircularBrush', 'ThresholdSphereBrush'];\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return toolNames;\r\n}\r\n\r\nexport default SegmentationToolbox;\r\n","import React from 'react';\r\n\r\nimport { useAppConfig } from '@state';\r\nimport PanelSegmentation from './panels/PanelSegmentation';\r\nimport SegmentationToolbox from './panels/SegmentationToolbox';\r\n\r\nconst getPanelModule = ({ commandsManager, servicesManager, extensionManager, configuration }) => {\r\n  const { customizationService } = servicesManager.services;\r\n\r\n  const wrappedPanelSegmentation = configuration => {\r\n    const [appConfig] = useAppConfig();\r\n\r\n    const disableEditingForMode = customizationService.get('segmentation.disableEditing');\r\n\r\n    return (\r\n      <PanelSegmentation\r\n        commandsManager={commandsManager}\r\n        servicesManager={servicesManager}\r\n        extensionManager={extensionManager}\r\n        configuration={{\r\n          ...configuration,\r\n          disableEditing: appConfig.disableEditing || disableEditingForMode?.value,\r\n        }}\r\n      />\r\n    );\r\n  };\r\n\r\n  const wrappedPanelSegmentationWithTools = configuration => {\r\n    const [appConfig] = useAppConfig();\r\n    return (\r\n      <>\r\n        <SegmentationToolbox\r\n          commandsManager={commandsManager}\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          configuration={{\r\n            ...configuration,\r\n          }}\r\n        />\r\n        <PanelSegmentation\r\n          commandsManager={commandsManager}\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          configuration={{\r\n            ...configuration,\r\n          }}\r\n        />\r\n      </>\r\n    );\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'panelSegmentation',\r\n      iconName: 'tab-segmentation',\r\n      iconLabel: 'Segmentation',\r\n      label: 'Segmentation',\r\n      component: wrappedPanelSegmentation,\r\n    },\r\n    {\r\n      name: 'panelSegmentationWithTools',\r\n      iconName: 'tab-segmentation',\r\n      iconLabel: 'Segmentation',\r\n      label: 'Segmentation',\r\n      component: wrappedPanelSegmentationWithTools,\r\n    },\r\n  ];\r\n};\r\n\r\nexport default getPanelModule;\r\n","import { Enums, cache } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Updates the viewports in preparation for rendering segmentations.\r\n * Evaluates each viewport to determine which need modifications,\r\n * then for those viewports, changes them to a volume type and ensures\r\n * they are ready for segmentation rendering.\r\n *\r\n * @param {Object} params - Parameters for the function.\r\n * @param params.viewportId - ID of the viewport to be updated.\r\n * @param params.loadFn - Function to load the segmentation data.\r\n * @param params.servicesManager - The services manager.\r\n * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\r\n *\r\n * @returns Returns true upon successful update of viewports for segmentation rendering.\r\n */\r\nasync function updateViewportsForSegmentationRendering({\r\n  viewportId,\r\n  loadFn,\r\n  servicesManager,\r\n  referencedDisplaySetInstanceUID,\r\n}: {\r\n  viewportId: string;\r\n  loadFn: () => Promise<string>;\r\n  servicesManager: any;\r\n  referencedDisplaySetInstanceUID?: string;\r\n}) {\r\n  const { cornerstoneViewportService, segmentationService, viewportGridService } =\r\n    servicesManager.services;\r\n\r\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n  const targetViewportId = viewport.viewportOptions.viewportId;\r\n\r\n  referencedDisplaySetInstanceUID =\r\n    referencedDisplaySetInstanceUID || viewport?.displaySetInstanceUIDs[0];\r\n\r\n  const updatedViewports = getUpdatedViewportsForSegmentation({\r\n    servicesManager,\r\n    viewportId,\r\n    referencedDisplaySetInstanceUID,\r\n  });\r\n\r\n  // create Segmentation callback which needs to be waited until\r\n  // the volume is created (if coming from stack)\r\n  const createSegmentationForVolume = async () => {\r\n    const segmentationId = await loadFn();\r\n    segmentationService.hydrateSegmentation(segmentationId);\r\n  };\r\n\r\n  // the reference volume that is used to draw the segmentation. so check if the\r\n  // volume exists in the cache (the target Viewport is already a volume viewport)\r\n  const volumeExists = Array.from(cache._volumeCache.keys()).some(volumeId =>\r\n    volumeId.includes(referencedDisplaySetInstanceUID)\r\n  );\r\n\r\n  updatedViewports.forEach(async viewport => {\r\n    viewport.viewportOptions = {\r\n      ...viewport.viewportOptions,\r\n      viewportType: 'volume',\r\n      needsRerendering: true,\r\n    };\r\n    const viewportId = viewport.viewportId;\r\n\r\n    const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n    const prevCamera = csViewport.getCamera();\r\n\r\n    // only run the createSegmentationForVolume for the targetViewportId\r\n    // since the rest will get handled by cornerstoneViewportService\r\n    if (volumeExists && viewportId === targetViewportId) {\r\n      await createSegmentationForVolume();\r\n      return;\r\n    }\r\n\r\n    const createNewSegmentationWhenVolumeMounts = async evt => {\r\n      const isTheActiveViewportVolumeMounted = evt.detail.volumeActors?.find(ac =>\r\n        ac.uid.includes(referencedDisplaySetInstanceUID)\r\n      );\r\n\r\n      // Note: make sure to re-grab the viewport since it might have changed\r\n      // during the time it took for the volume to be mounted, for instance\r\n      // the stack viewport has been changed to a volume viewport\r\n      const volumeViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n      volumeViewport.setCamera(prevCamera);\r\n\r\n      volumeViewport.element.removeEventListener(\r\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n        createNewSegmentationWhenVolumeMounts\r\n      );\r\n\r\n      if (!isTheActiveViewportVolumeMounted) {\r\n        // it means it is one of those other updated viewports so just update the camera\r\n        return;\r\n      }\r\n\r\n      if (viewportId === targetViewportId) {\r\n        await createSegmentationForVolume();\r\n      }\r\n    };\r\n\r\n    csViewport.element.addEventListener(\r\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n      createNewSegmentationWhenVolumeMounts\r\n    );\r\n  });\r\n\r\n  // Set the displaySets for the viewports that require to be updated\r\n  viewportGridService.setDisplaySetsForViewports(updatedViewports);\r\n\r\n  return true;\r\n}\r\n\r\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\r\n  const { viewports, activeViewportId } = viewportGridService.getState();\r\n  const targetViewportId = viewportId || activeViewportId;\r\n\r\n  const viewport = viewports.get(targetViewportId);\r\n\r\n  return viewport;\r\n};\r\n\r\n/**\r\n * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\r\n * This function evaluates viewports based on their compatibility with the provided segmentation's\r\n * frame of reference UID and appends them to the updated list if they should render the segmentation.\r\n *\r\n * @param {Object} params - Parameters for the function.\r\n * @param params.viewportId - the ID of the viewport to be updated.\r\n * @param params.servicesManager - The services manager\r\n * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\r\n *\r\n * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\r\n */\r\nfunction getUpdatedViewportsForSegmentation({\r\n  viewportId,\r\n  servicesManager,\r\n  referencedDisplaySetInstanceUID,\r\n}) {\r\n  const { hangingProtocolService, displaySetService, segmentationService, viewportGridService } =\r\n    servicesManager.services;\r\n\r\n  const { viewports } = viewportGridService.getState();\r\n\r\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n  const targetViewportId = viewport.viewportOptions.viewportId;\r\n\r\n  const displaySetInstanceUIDs = viewports.get(targetViewportId).displaySetInstanceUIDs;\r\n\r\n  const referenceDisplaySetInstanceUID =\r\n    referencedDisplaySetInstanceUID || displaySetInstanceUIDs[0];\r\n\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(referenceDisplaySetInstanceUID);\r\n  const segmentationFrameOfReferenceUID = referencedDisplaySet.instances[0].FrameOfReferenceUID;\r\n\r\n  const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\r\n    targetViewportId,\r\n    referenceDisplaySetInstanceUID\r\n  );\r\n\r\n  viewports.forEach((viewport, viewportId) => {\r\n    if (\r\n      targetViewportId === viewportId ||\r\n      updatedViewports.find(v => v.viewportId === viewportId)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\r\n      viewport.displaySetInstanceUIDs,\r\n      segmentationFrameOfReferenceUID\r\n    );\r\n\r\n    if (shouldDisplaySeg) {\r\n      updatedViewports.push({\r\n        viewportId,\r\n        displaySetInstanceUIDs: viewport.displaySetInstanceUIDs,\r\n        viewportOptions: {\r\n          viewportType: 'volume',\r\n          needsRerendering: true,\r\n        },\r\n      });\r\n    }\r\n  });\r\n  return updatedViewports;\r\n}\r\n\r\nexport {\r\n  updateViewportsForSegmentationRendering,\r\n  getUpdatedViewportsForSegmentation,\r\n  getTargetViewport,\r\n};\r\n","import dcmjs from 'dcmjs';\r\nimport { createReportDialogPrompt } from '@ohif/extension-default';\r\nimport { ServicesManager, Types } from '@ohif/core';\r\nimport { cache, metaData } from '@cornerstonejs/core';\r\nimport {\r\n  segmentation as cornerstoneToolsSegmentation,\r\n  Enums as cornerstoneToolsEnums,\r\n} from '@cornerstonejs/tools';\r\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\r\nimport { classes, DicomMetadataStore } from '@ohif/core';\r\n\r\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\n\r\nimport {\r\n  updateViewportsForSegmentationRendering,\r\n  getUpdatedViewportsForSegmentation,\r\n  getTargetViewport,\r\n} from './utils/hydrationUtils';\r\n\r\nconst { datasetToBlob } = dcmjs.data;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    Segmentation: { generateLabelMaps2DFrom3D, generateSegmentation },\r\n  },\r\n} = adaptersSEG;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    RTSS: { generateRTSSFromSegmentations },\r\n  },\r\n} = adaptersRT;\r\n\r\nconst { downloadDICOMData } = helpers;\r\n\r\nconst commandsModule = ({\r\n  servicesManager,\r\n  extensionManager,\r\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\r\n  const {\r\n    uiNotificationService,\r\n    segmentationService,\r\n    uiDialogService,\r\n    displaySetService,\r\n    viewportGridService,\r\n  } = (servicesManager as ServicesManager).services;\r\n\r\n  const actions = {\r\n    /**\r\n     * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\r\n     * This function evaluates viewports based on their compatibility with the provided segmentation's\r\n     * frame of reference UID and appends them to the updated list if they should render the segmentation.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - the ID of the viewport to be updated.\r\n     * @param params.servicesManager - The services manager\r\n     * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\r\n     *\r\n     * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\r\n     */\r\n    getUpdatedViewportsForSegmentation,\r\n    /**\r\n     * Creates an empty segmentation for a specified viewport.\r\n     * It first checks if the display set associated with the viewport is reconstructable.\r\n     * If not, it raises a notification error. Otherwise, it creates a new segmentation\r\n     * for the display set after handling the necessary steps for making the viewport\r\n     * a volume viewport first\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    createEmptySegmentationForViewport: async ({ viewportId }) => {\r\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n      // Todo: add support for multiple display sets\r\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n      if (!displaySet.isReconstructable) {\r\n        uiNotificationService.show({\r\n          title: 'Segmentation',\r\n          message: 'Segmentation is not supported for non-reconstructible displaysets yet',\r\n          type: 'error',\r\n        });\r\n        return;\r\n      }\r\n\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        loadFn: async () => {\r\n          const currentSegmentations = segmentationService.getSegmentations();\r\n          const segmentationId = await segmentationService.createSegmentationForDisplaySet(\r\n            displaySetInstanceUID,\r\n            { label: `Segmentation ${currentSegmentations.length + 1}` }\r\n          );\r\n\r\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\r\n\r\n          await segmentationService.addSegmentationRepresentationToToolGroup(\r\n            toolGroupId,\r\n            segmentationId\r\n          );\r\n\r\n          // Add only one segment for now\r\n          segmentationService.addSegment(segmentationId, {\r\n            toolGroupId,\r\n            segmentIndex: 1,\r\n            properties: {\r\n              label: 'Segment 1',\r\n            },\r\n          });\r\n\r\n          return segmentationId;\r\n        },\r\n      });\r\n    },\r\n    /**\r\n     * Loads segmentations for a specified viewport.\r\n     * The function prepares the viewport for rendering, then loads the segmentation details.\r\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentations - Array of segmentations to be loaded.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        loadFn: async () => {\r\n          // Todo: handle adding more than one segmentation\r\n          const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n          const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n          const segmentation = segmentations[0];\r\n          const segmentationId = segmentation.id;\r\n          const label = segmentation.label;\r\n          const segments = segmentation.segments;\r\n\r\n          delete segmentation.segments;\r\n\r\n          await segmentationService.createSegmentationForDisplaySet(displaySetInstanceUID, {\r\n            segmentationId,\r\n            label,\r\n          });\r\n\r\n          if (segmentation.scalarData) {\r\n            const labelmapVolume = segmentationService.getLabelmapVolume(segmentationId);\r\n            labelmapVolume.scalarData.set(segmentation.scalarData);\r\n          }\r\n\r\n          segmentationService.addOrUpdateSegmentation(segmentation);\r\n\r\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\r\n          await segmentationService.addSegmentationRepresentationToToolGroup(\r\n            toolGroupId,\r\n            segmentationId\r\n          );\r\n\r\n          segments.forEach(segment => {\r\n            if (segment === null) {\r\n              return;\r\n            }\r\n            segmentationService.addSegment(segmentationId, {\r\n              segmentIndex: segment.segmentIndex,\r\n              toolGroupId,\r\n              properties: {\r\n                color: segment.color,\r\n                label: segment.label,\r\n                opacity: segment.opacity,\r\n                isLocked: segment.isLocked,\r\n                visibility: segment.isVisible,\r\n                active: segmentation.activeSegmentIndex === segment.segmentIndex,\r\n              },\r\n            });\r\n          });\r\n\r\n          if (segmentation.centroidsIJK) {\r\n            segmentationService.setCentroids(segmentation.id, segmentation.centroidsIJK);\r\n          }\r\n\r\n          return segmentationId;\r\n        },\r\n      });\r\n    },\r\n    /**\r\n     * Loads segmentation display sets for a specified viewport.\r\n     * Depending on the modality of the display set (SEG or RTSTRUCT),\r\n     * it chooses the appropriate service function to create\r\n     * the segmentation for the display set.\r\n     * The function then prepares the viewport for rendering segmentation.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - ID of the viewport where the segmentation display sets should be loaded.\r\n     * @param params.displaySets - Array of display sets to be loaded for segmentation.\r\n     *\r\n     */\r\n    loadSegmentationDisplaySetsForViewport: async ({ viewportId, displaySets }) => {\r\n      // Todo: handle adding more than one segmentation\r\n      const displaySet = displaySets[0];\r\n\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        referencedDisplaySetInstanceUID: displaySet.referencedDisplaySetInstanceUID,\r\n        loadFn: async () => {\r\n          const segDisplaySet = displaySet;\r\n          const suppressEvents = false;\r\n          const serviceFunction =\r\n            segDisplaySet.Modality === 'SEG'\r\n              ? 'createSegmentationForSEGDisplaySet'\r\n              : 'createSegmentationForRTDisplaySet';\r\n\r\n          const boundFn = segmentationService[serviceFunction].bind(segmentationService);\r\n          const segmentationId = await boundFn(segDisplaySet, null, suppressEvents);\r\n\r\n          return segmentationId;\r\n        },\r\n      });\r\n    },\r\n    /**\r\n     * Generates a segmentation from a given segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * its referenced volume, extracts label maps from the\r\n     * segmentation volume, and produces segmentation data\r\n     * alongside associated metadata.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be generated.\r\n     * @param params.options - Optional configuration for the generation process.\r\n     *\r\n     * @returns Returns the generated segmentation data.\r\n     */\r\n    generateSegmentation: ({ segmentationId, options = {} }) => {\r\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\r\n\r\n      const { referencedVolumeId } = segmentation.representationData.LABELMAP;\r\n\r\n      const segmentationVolume = cache.getVolume(segmentationId);\r\n      const referencedVolume = cache.getVolume(referencedVolumeId);\r\n      const referencedImages = referencedVolume.getCornerstoneImages();\r\n\r\n      const labelmapObj = generateLabelMaps2DFrom3D(segmentationVolume);\r\n\r\n      // Generate fake metadata as an example\r\n      labelmapObj.metadata = [];\r\n\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      labelmapObj.segmentsOnLabelmap.forEach(segmentIndex => {\r\n        // segmentation service already has a color for each segment\r\n        const segment = segmentationInOHIF?.segments[segmentIndex];\r\n        const { label, color } = segment;\r\n\r\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\r\n          color.slice(0, 3).map(value => value / 255)\r\n        ).map(value => Math.round(value));\r\n\r\n        const segmentMetadata = {\r\n          SegmentNumber: segmentIndex.toString(),\r\n          SegmentLabel: label,\r\n          SegmentAlgorithmType: 'MANUAL',\r\n          SegmentAlgorithmName: 'OHIF Brush',\r\n          RecommendedDisplayCIELabValue,\r\n          SegmentedPropertyCategoryCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n          SegmentedPropertyTypeCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n        };\r\n        labelmapObj.metadata[segmentIndex] = segmentMetadata;\r\n      });\r\n\r\n      const generatedSegmentation = generateSegmentation(\r\n        referencedImages,\r\n        labelmapObj,\r\n        metaData,\r\n        options\r\n      );\r\n\r\n      return generatedSegmentation;\r\n    },\r\n    /**\r\n     * Downloads a segmentation based on the provided segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * uses it to generate the corresponding DICOM dataset, which\r\n     * is then downloaded with an appropriate filename.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\r\n     *\r\n     */\r\n    downloadSegmentation: ({ segmentationId }) => {\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const generatedSegmentation = actions.generateSegmentation({\r\n        segmentationId,\r\n      });\r\n\r\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\r\n    },\r\n    /**\r\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\r\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\r\n     * and in its absence, defaults to 'Research Derived Series'.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be stored.\r\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\r\n     *\r\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\r\n     * otherwise throws an error.\r\n     */\r\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\r\n      const promptResult = await createReportDialogPrompt(uiDialogService, {\r\n        extensionManager,\r\n      });\r\n\r\n      if (promptResult.action !== 1 && promptResult.value) {\r\n        return;\r\n      }\r\n\r\n      const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n      if (!segmentation) {\r\n        throw new Error('No segmentation found');\r\n      }\r\n\r\n      const { label } = segmentation;\r\n      const SeriesDescription = promptResult.value || label || 'Research Derived Series';\r\n\r\n      const generatedData = actions.generateSegmentation({\r\n        segmentationId,\r\n        options: {\r\n          SeriesDescription,\r\n        },\r\n      });\r\n\r\n      if (!generatedData || !generatedData.dataset) {\r\n        throw new Error('Error during segmentation generation');\r\n      }\r\n\r\n      const { dataset: naturalizedReport } = generatedData;\r\n\r\n      await dataSource.store.dicom(naturalizedReport);\r\n\r\n      // The \"Mode\" route listens for DicomMetadataStore changes\r\n      // When a new instance is added, it listens and\r\n      // automatically calls makeDisplaySets\r\n\r\n      // add the information for where we stored it to the instance as well\r\n      naturalizedReport.wadoRoot = dataSource.getConfig().wadoRoot;\r\n\r\n      DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n      return naturalizedReport;\r\n    },\r\n    /**\r\n     * Converts segmentations into RTSS for download.\r\n     * This sample function retrieves all segentations and passes to\r\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\r\n     * converts dataset to downloadable blob.\r\n     *\r\n     */\r\n    downloadRTSS: ({ segmentationId }) => {\r\n      const segmentations = segmentationService.getSegmentation(segmentationId);\r\n      const vtkUtils = {\r\n        vtkImageMarchingSquares,\r\n        vtkDataArray,\r\n        vtkImageData,\r\n      };\r\n\r\n      const RTSS = generateRTSSFromSegmentations(\r\n        segmentations,\r\n        classes.MetadataProvider,\r\n        DicomMetadataStore,\r\n        cache,\r\n        cornerstoneToolsEnums,\r\n        vtkUtils\r\n      );\r\n\r\n      try {\r\n        const reportBlob = datasetToBlob(RTSS);\r\n\r\n        //Create a URL for the binary.\r\n        const objectUrl = URL.createObjectURL(reportBlob);\r\n        window.location.assign(objectUrl);\r\n      } catch (e) {\r\n        console.warn(e);\r\n      }\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    getUpdatedViewportsForSegmentation: {\r\n      commandFn: actions.getUpdatedViewportsForSegmentation,\r\n    },\r\n    loadSegmentationDisplaySetsForViewport: {\r\n      commandFn: actions.loadSegmentationDisplaySetsForViewport,\r\n    },\r\n    loadSegmentationsForViewport: {\r\n      commandFn: actions.loadSegmentationsForViewport,\r\n    },\r\n    createEmptySegmentationForViewport: {\r\n      commandFn: actions.createEmptySegmentationForViewport,\r\n    },\r\n    generateSegmentation: {\r\n      commandFn: actions.generateSegmentation,\r\n    },\r\n    downloadSegmentation: {\r\n      commandFn: actions.downloadSegmentation,\r\n    },\r\n    storeSegmentation: {\r\n      commandFn: actions.storeSegmentation,\r\n    },\r\n    downloadRTSS: {\r\n      commandFn: actions.downloadRTSS,\r\n    },\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { id } from './id';\r\nimport React from 'react';\r\n\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getHangingProtocolModule from './getHangingProtocolModule';\r\nimport getPanelModule from './getPanelModule';\r\nimport getCommandsModule from './commandsModule';\r\nimport preRegistration from './init';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\r\n});\r\n\r\nconst OHIFCornerstoneSEGViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n  preRegistration,\r\n\r\n  /**\r\n   * PanelModule should provide a list of panels that will be available in OHIF\r\n   * for Modes to consume and render. Each panel is defined by a {name,\r\n   * iconName, iconLabel, label, component} object. Example of a panel module\r\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\r\n   */\r\n  getPanelModule,\r\n  getCommandsModule,\r\n\r\n  getViewportModule({ servicesManager, extensionManager }) {\r\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSEGViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          commandsManager={commandsManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n  getHangingProtocolModule,\r\n};\r\n\r\nexport default extension;\r\n","import { addTool, BrushTool } from '@cornerstonejs/tools';\r\n\r\nexport default function init({ configuration = {} }): void {\r\n  addTool(BrushTool);\r\n}\r\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","Error","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","_ref","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","_ref2","utilityModule","getModuleEntry","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","cachedReferencedVolume","cache","getVolume","imageIds","tolerance","skipOverlapping","eventTarget","addEventListener","Enums","Events","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","EVENTS","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","generateToolState","metaData","triggerEvent","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","map","x","Math","round","assign","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","_load","_ref3","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","uiDialogService","label","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","title","noCloseButton","onClose","actions","text","type","ButtonEnums","secondary","primary","onSubmit","body","setValue","React","Input","labelClassName","autoFocus","className","onChange","event","persist","target","onKeyPress","key","rgbaColor","ChromePicker","color","rgb","presetColors","width","PanelSegmentation","commandsManager","configuration","viewportGridService","t","useTranslation","selectedSegmentationId","setSelectedSegmentationId","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","segmentations","setSegmentations","getSegmentations","useEffect","added","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","subscriptions","unsubscribe","subscribe","push","unsub","getToolGroupIds","segmentationId","getToolGroupIdsWithSegmentation","_setSegmentationConfiguration","useCallback","setConfiguration","SegmentationGroupTable","disableEditing","activeSegmentationId","onSegmentationAdd","runCommand","onSegmentationClick","setActiveSegmentationForToolGroup","onSegmentationDelete","remove","onSegmentationDownload","onSegmentationDownloadRTSS","storeSegmentation","datasources","getActiveDataSource","displaySetInstanceUIDs","createReportAsync","getReport","dataSource","reportType","setDisplaySetsForViewport","viewportId","getActiveViewportId","onSegmentationEdit","segmentation","callInputDialog","actionId","addOrUpdateSegmentation","onSegmentClick","segmentIndex","setActiveSegment","jumpToSegmentCenter","onSegmentEdit","segment","setSegmentLabel","onSegmentAdd","addSegment","onSegmentColorClick","opacity","r","g","b","a","callColorPickerDialog","newRgbaColor","setSegmentRGBAColor","onSegmentDelete","removeSegment","onToggleSegmentVisibility","isVisible","setSegmentVisibility","onToggleSegmentLock","toggleSegmentLocked","onToggleSegmentationVisibility","toggleSegmentationVisibility","showDeleteSegment","segmentationConfig","initialConfig","setRenderOutline","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setOutlineWidthActive","setFillAlpha","setFillAlphaInactive","propTypes","PropTypes","isRequired","segmentationUtils","utilities","TOOL_TYPES","CIRCULAR_BRUSH","SPHERE_BRUSH","CIRCULAR_ERASER","SPHERE_ERASER","CIRCLE_SHAPE","RECTANGLE_SHAPE","SPHERE_SHAPE","THRESHOLD_CIRCULAR_BRUSH","THRESHOLD_SPHERE_BRUSH","ACTIONS","SET_TOOL_CONFIG","SET_ACTIVE_TOOL","initialState","Brush","brushSize","mode","Eraser","Shapes","ThresholdBrush","thresholdRange","activeTool","toolboxReducer","state","tool","config","payload","_getToolNamesFromCategory","category","toolNames","toolbarService","toolGroupService","viewportGrid","useViewportGrid","activeViewportId","toolsEnabled","setToolsEnabled","dispatch","useReducer","updateActiveTool","size","undefined","viewport","get","getActiveToolForViewport","setToolActive","toolName","recordInteraction","interactionType","commands","commandName","commandOptions","events","unsubscriptions","activeSegmentation","find","seg","isActive","segmentCount","TOOL_BAR_STATE_MODIFIED","values","includes","updateBrushSize","setBrushSizeForToolGroup","onBrushSizeChange","valueAsStringOrNumber","toolCategory","Number","handleRangeChange","newRange","getToolGroup","setToolConfiguration","strategySpecificConfiguration","THRESHOLD_INSIDE_CIRCLE","threshold","AdvancedToolbox","items","icon","disabled","active","onClick","options","min","max","step","children","InputDoubleRange","minValue","maxValue","showLabel","allowNumberEdit","showAdjustmentArrows","customizationService","iconName","iconLabel","component","appConfig","useAppConfig","disableEditingForMode","SegmentationToolbox","updateViewportsForSegmentationRendering","loadFn","cornerstoneViewportService","getTargetViewport","targetViewportId","updatedViewports","getUpdatedViewportsForSegmentation","createSegmentationForVolume","hydrateSegmentation","volumeExists","Array","from","_volumeCache","some","volumeId","needsRerendering","csViewport","getCornerstoneViewport","prevCamera","getCamera","createNewSegmentationWhenVolumeMounts","isTheActiveViewportVolumeMounted","volumeActors","ac","uid","volumeViewport","setCamera","element","removeEventListener","VOLUME_VIEWPORT_NEW_VOLUME","setDisplaySetsForViewports","getState","hangingProtocolService","referenceDisplaySetInstanceUID","segmentationFrameOfReferenceUID","getDisplaySetByUID","FrameOfReferenceUID","getViewportsRequireUpdate","v","shouldRenderSegmentation","datasetToBlob","generateLabelMaps2DFrom3D","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","uiNotificationService","createEmptySegmentationForViewport","currentSegmentations","createSegmentationForDisplaySet","addSegmentationRepresentationToToolGroup","show","message","loadSegmentationsForViewport","scalarData","getLabelmapVolume","set","isLocked","visibility","activeSegmentIndex","centroidsIJK","setCentroids","loadSegmentationDisplaySetsForViewport","_ref4","serviceFunction","boundFn","bind","_ref5","cornerstoneToolsSegmentation","representationData","LABELMAP","segmentationVolume","getCornerstoneImages","labelmapObj","metadata","segmentationInOHIF","segmentsOnLabelmap","rgb2DICOMLAB","slice","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","SegmentAlgorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","_ref6","generatedSegmentation","dataset","_ref7","promptResult","createReportDialogPrompt","generatedData","naturalizedReport","store","dicom","getConfig","DicomMetadataStore","addInstances","downloadRTSS","_ref8","vtkUtils","vtkImageMarchingSquares","vtkDataArray","vtkImageData","classes","MetadataProvider","cornerstoneToolsEnums","reportBlob","objectUrl","URL","createObjectURL","window","location","e","warn","definitions","commandFn","Component","OHIFCornerstoneSEGViewport","props","fallback","preRegistration","addTool","BrushTool","getPanelModule","getCommandsModule","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}